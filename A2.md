
# A2 : Authentication & Authorization
---
## Authentication (User Authe.)
---
**Note :-** InfoSec : CIA -> Parkerian Hexad (Google it)

**Authe. Factors : KOI**
- **K**nowledge factors : password, PIN, security que. etc.
- **O**wnership factors : wrist band, ID card, HW/SW token etc.
- **I**nherence factors : fingerprint, retina, DNA, sign., face, voice etc,

**Types of Authe. :** (will discuss bold one's)
 - **Password based** - simple cookie based hashing user/pass etc. 
 - Passwordless - nothing but a hype term.
 - MFA (Multifactor auth)
 - Biometric, Captchas
 - Certificate Based (Digital Sign.) - uses SSO
 - Single Sign-On (SSO) - based on cookies 
 - **Token Based :** HTTP Basic, API Key, OAuth/OIDC (JWT)
 
**Types of Authe. Protocol** : Based on stateful & stateless authe. (will discuss bold ones) 
 - **HTTP Autho. Header (Basic Schema)** (Other Schema - Bearer, Digest, HMAC, etc.) - require no cookies, SID, login page etc.
 - **OpenID/OIDC** (on top of OAuth 2.0) - will discuss in Authorization
 - **SAML** (Closely used as alternate to OIDC)
 - **JWT** : JWS/JWE/JWK/JWA
 -  Kerberos
 - LDAP
 - PAP
 - CHAP
 - EAP
 - P2P
 - FIDO2 - UAF, U2F
 - SSL/TLS - Uses public key cryptography - digital certificates
 - AAA architecture protocols :
	 - TACACS, XTACACS and TACACS+
	 - RADIUS (LoginRadius)
	 - DIAMETER
 - Others : Hawk authe, AWS Sign., NTLM, Etc... (See wiki for more) 


**User Authentication choice/ways** :

**NOTE on Session Management** :
 - **Client Side** - Session info. is stored in cookie (user data are openly exposed), URL querystring, hidden form field, View state
 - **Server side** - Server sets SID in cookie(Only SID is exposed, rest data stored in db - widely used), App state, Session state.
---

- **Old/Obslete Methods (Rarely used) :** 
  - **IP address** :  The server knows the IP address of the computer running the browser and could theoretically link a user's session to this IP address. However, IP addresses are generally not a reliable way to track a session or identify a user.
  - URL query string : A querystring is information added to the end of a page's URL using "?" as the separator between the URL and the querystring and "&" to separate each querystring pair. Eg: http://www.examplesite.com?sid=Hu33Ymd923Js1ULsd45
	  - Pros : 
		  - Lightweight and easy to employ.
		  - Useful when client browser cookie function is disabled.
		  - Transferable through a copy of the URL.
	  - Cons : 
		  - URL length has limitations: usually 255-character
		  - Visible and easy to tampered.
		  - If a user visits a page by coming from a page internal to the site the first time, and then visits the same page by coming from an external search engine the second time, the query strings would likely be different. If cookies were used in this situation, the cookies would be the same.
  - **Hidden form fields** : A hidden form field is not visible in the browser, but the value can be sent to the server along with the other form fields. Example: \<input type=hidden name=sid value=Hu33Ymd923Js1ULsd45>
	  - GET - Similar to URL query strings (add form field to url). 
	  - POST - form information & hidden fields sent in HTTP request body (Neither url nor cookie)
	  - Pros : 
		  - Not as visible as the querystring.
		  - session info is not copied when the user copies the URL (to bookmark the page or send it via email, for example)
	  - Cons : 
		  - docs need to embedd data inside, waste bandwidth. have to embed the result from the previous page on the next page.
		  - Everyone can see the embedded data by viewing the original source code.
		  - We cannot store all kinds of objects in hidden boxes except text/string values.
		  - Hidden boxes travel over the network along with the request and response, indicates more network traffic.
  - **"window.name" DOM property** : All current web browsers can store a fairly large amount of data (2–32 MB) via JavaScript using the DOM property window.name. This data can be used instead of session cookies and is also cross-domain. The technique can be coupled with JSON/JavaScript objects to store complex sets of session variables on the client side.The downside is that every separate window or tab will initially have an empty window.name property when opened. Furthermore, the property can be used for tracking visitors across different websites, making it of concern for Internet privacy. In some respects, this can be more secure than cookies due to the fact that its contents are not automatically sent to the server on every request like cookies are, so it is not vulnerable to network cookie sniffing attacks. However, if special measures are not taken to protect the data, it is vulnerable to other attacks because the data is available across different websites opened in the same window or tab.
  - **HTTP Authentication & Authorization Framework :**  
	  - **Basic Schema** - Oldest method, only to be used with https, not used widely. No login page required, username/password will be by default prompted to User by browser. It transmits credentials as user ID/password pairs, encoded using base64. 
		  - The **server** responds to client with `401`(Unauthorized) response status & provides info. on how to authorize with **`www-Authenticate` response header** containing at least one challenge. Eg. **www-Authenticate: \<Basic> realm=\<access to site>**
		  - A **client** that wants to authenticate itself with the server can then do so by including an **`Authorization` request header** with the credentials - Key/value, JWTokens Etc. Eg. **Authorization: \<Basic> \<Hu33Ymd923Js1ULsd45>**
		  - If All goes well, page/response is displayed. Session established. 
	  - Other Schemas - Bearer, Digest, HOBA, AWS3, Etc.
	  - **Pros** : Implementation is simplest bcz it does not require cookies, SID/login pages, rather uses standard fields in HTTP header (Server : www-authenticate & Client : authorization).
	  - **Cons :** Basic Schema has no way to logout/revoke user & is unsafe (without https).

- **Traditional Method (used presently) : Stateful session management**
  - **Cookie based authentication (server side)** - SID stored into cookies (1st party session cookies) & sent back to server on each http req. header automatically.
	  - **Note** : **See Cookie topic for details (HTTP + Cookies = Stateful)**
	  - Lib. : Passport-local strategy (uses express.session internally) 
	  - State Store : DB, Redis Cache DB, Filesystem etc. 
	  - Web FW : ASP.NET, django, nodejs etc. support via session management API for session based authentication.

- **Modern Method : Stateless session management (JWT) & Hybrid Approach**
  - **Stateless/Client Side/cookieless/Token Based Authe (General)** - JWTokens, Passport/Passport-jwt strategy
           XXXXXXXXXXXXXXXXXXXXXXXXXXXX
  - **Stateful JWT (JWT + Session Tokens Stored in cookie])** - Using JWT's as Session (Not recommended)
       XXXXXXXXXXXXXXXXXXXXXXXXXXXX
  - **Stateless JWT** - Usage of refresh and access tokens (Recommended & Widely used) [3rd party lib - AWS cognito, Firebase etc.]
       XXXXXXXXXXXXXXXXXXXXXXXXXXXX

---

## Authorization (User Autho./Access Control)
---
**NOTE :** There is no specific type/protocol for authorization. Some are HTTP Autho. & OAuth 2.0/OIDC. We will discuss here only **OAuth 2.0/OIDC**. To delegate Autho. use - Authorization as a Service (Eg. Cerbos) 

**Access Control System (Autho.) Factors :** 
- AAA : Authentication, Authorization, Accountability/Auditing
	- Identity & Access Mgmt. (IAM)
- Other keywords : 
	- Access control List, Access control matrix
	- Authorization OSID (Similar to Authentication OSID)

**Authorization/Access Control Model** : 

**NOTE** : As per OWASP, prefer ABAC & ReBAC over RBAC.
- **RBAC** (Role-Based-Access-Control) : RBAC is a model of access control in which access is granted or denied based upon the roles assigned to a user.A role is nothing but a collection of permissions. Permissions are not directly assigned to an entity; rather, permissions are associated with a role and the entity inherits the permissions of any roles assigned to it. Generally, the relationship between roles and users can be many-to-many, and roles may be hierarchical in nature. RBAC treats authorization as permissions associated with roles and not directly with users attribute. For example, imagine that you work as a department manager in an organization. In this situation, you should have permissions that reflect your role, for example, the ability to approve vacation requests and expense requests, assign tasks, and so on. To grant these permissions, a system manager would first create a role called "Manager" (or similar). Then, they would assign these permissions to this role and would associate you with the "Manager" role. Of course, other users that need the same set of permissions can be associated with that role.
	- **Pros** : Managing authorization privileges becomes easier because sysadmin can deal with users and permissions in bulk instead of having to deal with them one by one. consider RBAC if :
		- You’re in a small- to medium-sized enterprise
		- Your access control policies are broad 
		- You have few external users, and your organization roles are clearly defined.
	- **Cons** : RBAC simplicity is also a big disadvantage in systems as they scale. You can’t assign granular permissions like project and team-level administrative access without expanding your roles table. This makes maintaining RBAC a headache in a SaaS application with lots of users and permission levels.
- **ABAC** (Attribute-Based-Access-Control) : In ABAC "subject requests to perform operations on objects are granted or denied based on assigned attributes of the subject, assigned attributes of the object, environment conditions, and a set of policies that are specified in terms of those attributes and conditions". Attributes are simply characteristics that be represented as name-value pairs and assigned to a subject, object, or the environment. When using ABAC, a computer system defines whether a user has sufficient access privileges to execute an action based on a trait (attribute or claim) associated with that user. 
	- Eg. online store that sells alcoholic beverages provided proof of their age : Alcoholic beverage = resource | Online store = resource owner | Age of consumer validated during registration process is claim, that is proof of user’s age attribute. Presenting the age claim allows the store to process access requests to buy alcohol. So, in this case, the decision to grant access to the resource is made upon the user attribute.
	- **Pros** : Flexibility - ABAC allows admins to implement granular, policy-based access control, using different combinations of attributes to create conditions of access that are as specific or broad as the situation calls for. In short, choose ABAC if:
		- You’re in a large organization with many users
		- You want deep, specific access control capabilities
		- You have time to invest in a model that goes the distance
		- You need to ensure privacy and security compliance
	- **Cons** : Implementation complexity - Admins need to manually define attributes, assign them to every component, and create a central policy engine that determines what attributes are allowed to do, based on various conditions (“if X, then Y”).
- **ReBAC** (Relationship Based Access Control) : “Does this user have a sufficient relationship to this object or action such that they can access it?” ReBAC grants access based on the relationships between resources. For instance, allowing only the user who created a post to edit it. This is especially necessary in social network applications, like Twitter or Facebook, where users want to limit access to their data (tweets or posts) to people they choose (friends, family, followers).
	- **Pros** : Supports Multi-Tenancy and Cross-Organizational Requests, Ease of Management. Support fine-grained, complex Boolean logic, Robustness, Speed.
- Others : 
	- Graph-Based Access Control (GBAC)
	- Discretionary Access Control (DAC)
	- History-Based Access Control (HBAC)
	- History-of-Presence Based Access Control (HPBAC)
	- Identity-Based Access Control (IBAC)
	- Lattice-Based Access Control (LBAC)
	- Mandatory Access Control (MAC)
	- Organization-Based Access Control (OrBAC) 
	- Rule-Based Access Control (RAC)/Rule-Based Role-Based Access Control (RB-RBAC)
	- Responsibility Based Access Control (RespBAC)


**User Authorization Choice** [OAuth/OAuth 2.0 -> OpenID/OIDC]
**NOTE** : 3rd Party Library - passport.js strategy, identity providers (Auth0,Okta,etc)

- **OAuth/OAuth 2.0 :** Authorization Protocol (Psuedo Authentication)
	XXXXXXXXXXXXXXXXXXXXXXXXXXXXX

- **OpenID/OIDC & SAML :** Identity Authentication Protocol build on top of OAuth [Used for SSO - IPC]
	XXXXXXXXXXXXXXXXXXXXXXXXXXXXX

---



