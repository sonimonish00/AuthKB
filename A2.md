
# A2 : Authentication & Authorization
---
## Authentication (User Authe.)
---
**Note :-** InfoSec : CIA -> Parkerian Hexad (Google it)

**Authe. Factors : KOI**
- **K**nowledge factors : password, PIN, security que. etc.
- **O**wnership factors : wrist band, ID card, HW/SW token etc.
- **I**nherence factors : fingerprint, retina, DNA, sign., face, voice etc,

**Types of Authe. :** (will discuss bold one's)
 - **Password based** - simple cookie based hashing user/pass etc. 
 - Passwordless - nothing but a hype term.
 - MFA (Multifactor auth)
 - Biometric, Captchas
 - Certificate Based (Digital Sign.) - uses SSO
 - Single Sign-On (SSO) - based on cookies 
 - **Token Based :** HTTP Basic, API Key, OAuth/OIDC (JWT)
 
**Types of Authe. Protocol** : Based on stateful & stateless authe. (will discuss bold ones) 
 - **HTTP Autho. Header (Basic Schema)** (Other Schema - Bearer, Digest, HMAC, etc.) - require no cookies, SID, login page etc.
 - **OpenID/OIDC** (on top of OAuth 2.0) - will discuss in Authorization
 - **SAML** (Closely used as alternate to OIDC)
 - **JWT** : JWS/JWE/JWK/JWA
 -  Kerberos
 - LDAP
 - PAP
 - CHAP
 - EAP
 - P2P
 - FIDO2 - UAF, U2F
 - SSL/TLS - Uses public key cryptography - digital certificates
 - AAA architecture protocols :
	 - TACACS, XTACACS and TACACS+
	 - RADIUS (LoginRadius)
	 - DIAMETER
 - Others : Hawk authe, AWS Sign., NTLM, Etc... (See wiki for more) 

**User Authentication choice/ways** :

**NOTE on Session Management** :
 - **Client Side** - Session info. is stored in cookie (user data are openly exposed), URL querystring, hidden form field, View state
 - **Server side** - Server sets SID in cookie(Only SID is exposed, rest data stored in db - widely used), App state, Session state.
---
**Old/Obslete Methods (Rarely used) :** 
 - **IP address :**  
 - **URL query string :** 
 - **Hidden form fields :** 
 - **"window.name" DOM property :** 
 - **HTTP Authentication Schemas :**  

**Traditional Method (Used presently) : Stateful Session mgmt.**
- **Stateful/Server/Session Based/Cookie based Authe**.  - SID stord into cookies - Passport/Passport-local strategy -> Utilizes cookies,express session etc. 

**Modern Method : Stateless Session mgmt. & Hybrid Approach**
 - **Stateless/Client Side/cookieless/Token Based Authe (General)** - JWTokens, Passport/Passport-jwt strategy
XXXXXXXXXXXXXXXXXXXXXXXXXXXX
 - **Stateful JWT (JWT + Session Tokens Stored in cookie])** - Using JWT's as Session (Not recommended)
XXXXXXXXXXXXXXXXXXXXXXXXXXXX
 - **Stateless JWT** - Usage of refresh and access tokens (Recommended & Widely used) [3rd party lib - AWS cognito, Firebase etc.]
 XXXXXXXXXXXXXXXXXXXXXXXXXXXX

---

## Authorization (User Autho./Access Control)
---
**NOTE :** There is no specific type/protocol for authorization. Some are HTTP Autho. & OAuth 2.0/OIDC. We will discuss here only **OAuth 2.0/OIDC**. To delegate Autho. use - Authorization as a Service (Eg. Cerbos) 

**Access Control System (Autho.) Factors :** 
- AAA : Authentication, Authorization, Accountability/Auditing
	- Identity & Access Mgmt. (IAM)
- Other keywords : 
	- Access control List, Access control matrix
	- Authorization OSID (Similar to Authentication OSID)

**Authorization/Access Control Model** : 

**NOTE** : As per OWASP, prefer ABAC & ReBAC over RBAC.
- **RBAC** (Role-Based-Access-Control) : RBAC is a model of access control in which access is granted or denied based upon the roles assigned to a user.A role is nothing but a collection of permissions. Permissions are not directly assigned to an entity; rather, permissions are associated with a role and the entity inherits the permissions of any roles assigned to it. Generally, the relationship between roles and users can be many-to-many, and roles may be hierarchical in nature. RBAC treats authorization as permissions associated with roles and not directly with users attribute. For example, imagine that you work as a department manager in an organization. In this situation, you should have permissions that reflect your role, for example, the ability to approve vacation requests and expense requests, assign tasks, and so on. To grant these permissions, a system manager would first create a role called "Manager" (or similar). Then, they would assign these permissions to this role and would associate you with the "Manager" role. Of course, other users that need the same set of permissions can be associated with that role.
	- **Pros** : Managing authorization privileges becomes easier because sysadmin can deal with users and permissions in bulk instead of having to deal with them one by one. consider RBAC if :
		- You’re in a small- to medium-sized enterprise
		- Your access control policies are broad 
		- You have few external users, and your organization roles are clearly defined.
	- **Cons** : RBAC simplicity is also a big disadvantage in systems as they scale. You can’t assign granular permissions like project and team-level administrative access without expanding your roles table. This makes maintaining RBAC a headache in a SaaS application with lots of users and permission levels.
- **ABAC** (Attribute-Based-Access-Control) : In ABAC "subject requests to perform operations on objects are granted or denied based on assigned attributes of the subject, assigned attributes of the object, environment conditions, and a set of policies that are specified in terms of those attributes and conditions". Attributes are simply characteristics that be represented as name-value pairs and assigned to a subject, object, or the environment. When using ABAC, a computer system defines whether a user has sufficient access privileges to execute an action based on a trait (attribute or claim) associated with that user. 
	- Eg. online store that sells alcoholic beverages provided proof of their age : Alcoholic beverage = resource | Online store = resource owner | Age of consumer validated during registration process is claim, that is proof of user’s age attribute. Presenting the age claim allows the store to process access requests to buy alcohol. So, in this case, the decision to grant access to the resource is made upon the user attribute.
	- **Pros** : Flexibility - ABAC allows admins to implement granular, policy-based access control, using different combinations of attributes to create conditions of access that are as specific or broad as the situation calls for. In short, choose ABAC if:
		- You’re in a large organization with many users
		- You want deep, specific access control capabilities
		- You have time to invest in a model that goes the distance
		- You need to ensure privacy and security compliance
	- **Cons** : Implementation complexity - Admins need to manually define attributes, assign them to every component, and create a central policy engine that determines what attributes are allowed to do, based on various conditions (“if X, then Y”).
- **ReBAC** (Relationship Based Access Control) : “Does this user have a sufficient relationship to this object or action such that they can access it?” ReBAC grants access based on the relationships between resources. For instance, allowing only the user who created a post to edit it. This is especially necessary in social network applications, like Twitter or Facebook, where users want to limit access to their data (tweets or posts) to people they choose (friends, family, followers).
	- **Pros** : Supports Multi-Tenancy and Cross-Organizational Requests, Ease of Management. Support fine-grained, complex Boolean logic, Robustness, Speed.
- Others : 
	- Graph-Based Access Control (GBAC)
	- Discretionary Access Control (DAC)
	- History-Based Access Control (HBAC)
	- History-of-Presence Based Access Control (HPBAC)
	- Identity-Based Access Control (IBAC)
	- Lattice-Based Access Control (LBAC)
	- Mandatory Access Control (MAC)
	- Organization-Based Access Control (OrBAC) 
	- Rule-Based Access Control (RAC)/Rule-Based Role-Based Access Control (RB-RBAC)
	- Responsibility Based Access Control (RespBAC)


**User Authorization Choice** [OAuth/OAuth 2.0 -> OpenID/OIDC]
**NOTE** : 3rd Party Library - passport.js strategy, identity providers (Auth0,Okta,etc)

**OAuth/OAuth 2.0 :** Authorization Protocol (Psuedo Authentication)

XXXXXXXXXXXXXXXXXXXXXXXXXXXXX

**OpenID/OIDC & SAML :** Identity Authentication Protocol build on top of OAuth [Used for SSO - IPC]

XXXXXXXXXXXXXXXXXXXXXXXXXXXXX

---



---


